
### Js
1. 避免使用 eval 或 Function 构造器
2. 不要使用 with
3. 不要在要求性能的函数中使用 try-catch-finally 使用判断避免报错

    try-catch-finally 结构相当独特。与其它结构不同，它运行时会在当前作用域创建一个新变量。在每次 catch 子句运行的时候，这个变量会引用捕捉到的异常对象。这个变量不会存在于脚本的其它部分，哪怕是在相同的作用域中。它在 catch 子句开始的时候创建，并在这个子句结束的时候销毁。
    因为这个变量在运行时创建和销毁，并且在语句中代表着一种特殊的情况，某些浏览器不能很有效地处理它。因此如果把它放在一个要求性能的循环中，在捕捉到异常时可能造成性能问题。
4. 尽量不用全局变量
5. 注意对象的隐式转换
6. 在要求性能的函数中避免使用 for-in(Object.key() 中也用到了for in)
7. 使用累加形式连接字符串

        // 尽量使用
        a += 'x';
        a += 'y';
        // 而不是
        a += "x" + "y"
8. 基本运算比调用函数更快

        // 尽量使用
        var min = a < b ? a : b;
        A[A.length] = v;
        // 而不是
        var min = Math.min(a,b);
        A.push(v);
9. 为 setTimeout() 和 setInterval() 传入函数而不是字符串


### DOM
1. 重绘和重排

    1. 有东西从不可见变为可见，或者反之，但没有改变文档布局，就会触发重绘。比如为某个元素添加轮廓线，改变背景色或者改变 visibility 样式等。重绘很耗性能，因为它需要引擎搜索所有元素来决定什么是可见的，什么应该显示出来。

    2. 重排带来更大的变化。如果对 DOM 树进行了操作，或者某个样式改变了布局，比如元素的 className 属性改变时，或者浏览器窗口大小改变的时候。引擎必须对相关元素进行重排，以确定现在各个部分应该显示在哪里。子元素也会因父元素的变化重排。显示某个被重排的元素之后的元素也需要重新计算新的布局，与最开始的布局不同。由于子孙元素大小的改变，祖先元素也需要重排以适应新的大小。最后还需要对所有元素进行重绘。

    3. 重排特别消耗性能，它是造成 DOM 脚本缓慢的主要原因之一，这对处理器性能不高的设备，比如电话，尤其显著。多数情况下它相当于重新布局整个页面。

2. 将重排数量降到最低

   * 注意某些元素在重排时显示慢于其它元素。比如重排一个 table 需要 3 倍于等效块元素显示的时间。

3. 最小重排
    * 一般的重排会影响到整文档。文档中需要重排的东西越多，重排花的时间就越长。绝对(absolute)定位和固定(fixed)定位的元素不会影响主文档的布局，所以对它们的重排不会引起其它部分的连锁反应。文档中在它们之后的内容可能需要重绘来呈现变化，但这也远比一个完整的重排好得多。

    *  因此，动画不需要应用于整个文档，它最好只应用在一个固定位置的元素上。大多数动画都只需要考虑这个问题。

4. 修改文档树
    * 在 DOM 中添加新的幸免于难、改变文本节点的值、或者修改各种属性，都足以引起重排。多次连续地改变可能导致多次重排。因此，总的来说，最好在一段未显示出来的 DOM 树片段上进行多次改变，然后用一个单一的操作把改变应用在文档的 DOM 中。
    * 将多个元素一次挂载到DOM树上,而不是分次挂载。
5. 修改不可见的元素
    * 如果某个元素的 display 样式设置为 none，就不会对其进行重绘，哪怕它的内容发生改变。这都是因为它不可见，这是一种优势。如果需要对某个元素或者它的子元素进行改变，而且这些改变又不能合并在一个单独的重绘中，那就可以先设置这个元素的样式为 display:none，然后改变它，再把它设置为普通的显示状态。

6. 测量
    * 如前所述，浏览器会缓存一些变化，然后在这些变化都完成之后只进行一次重排。不过，测量元素会导致其强制重排。这种变化可能会，也可能不会引起明显地重绘，但重排仍然会在幕后发生。

    * 这种影响发生在使用像 offsetWidth 这样的属性，或者 getComputedStyle 这样的方法进行测量的时候。即使不使用这些数字，只要使用了它们，浏览器仍然会缓存改变，这足以触发隐藏的重排。如果这些测量需要重复进行，你就得考虑只测量一次，然后将结果保存起来以备后用。


7. 一次改变多项样式

        // 尽量使用
        div {
          background: #ddd;
          color: #000;
          border: 1px solid #000;}
        div.highlight {
          background: #333;
          color: #fff;
          border: 1px solid #00f;}
        …
        document.getElementById('mainelement').className = 'highlight';
        // 而不是
        var toChange = document.getElementById('mainelement');
        toChange.style.background = '#333';
        toChange.style.color = '#fff';
        toChange.style.border = '1px solid #00f';

8. 避免检索大量节点

        // 避免使用
        document.getElementsByTagName('*')
        // 应当先找到对用的class 或者 id 文件 在遍历其子元素

9. 避免在遍历 DOM 的时候进行修改

    * 如果你的脚本在像这样的集合中检索，同时又在向里面添加元素，那你可能进入一个无限循环，因为在到达终点前不断的往集合内添加项。不过，这不是唯一的问题。这些集合可能被优化以提升性能。它们能记住长度和脚本引用的最后一个索引，以便在增加索引的时候，能迅速引用下一个节点。

    * 它的工作原理是先建立一个静态元素列表用于修改，然后遍历这个静态列表来进行(所以遍历时添加,会直接添加元素到元素的列表)修改。以此避免对 getElementsByTagName 返回的列表进行修改。

            // 避免使用
            var allPara = document.getElementsByTagName('p');
            for(var i = 0; i < allPara.length; i++) {
                 allPara[i].appendChild(document.createTextNode(i));
            }
            // 使用
            var allPara = document.getElementsByTagName('p');
            var collectTemp = [];
            // 先存储
            for(var i = 0; i < allPara.length; i++) {
              collectTemp[collectTemp.length] = allPara[i];
            }
            for(i = 0; i < collectTemp.length; i++) {
              collectTemp[i].appendChild(document.createTextNode(i));
            }
            collectTemp = null;
10. 在脚本中用变量缓存 DOM 的值
 * DOM 返回的某些值是不缓存的，它们会在再次调用的时候重新计算。

### 文档加载
1. 避免在多个文档间保持同一个引用
  *  如果一个文档访问了另一个文档的节点或者对象，应该避免在脚本使用完它们之后仍然保留它们的引用。如果某个引用保存在当前文档的全局变量中，或者保存在某个长期存在的对象的属性中，通过将其设置为 null，或者通过 delete 来清除它。

2. location.replace() 控制历史记录
2. location.replace() 控制历史记录



